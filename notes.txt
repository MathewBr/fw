qУрок 2. Структура приложения.
=============================
ModuleViewController
Composer
{
  "autoload": {
    "psr-4": {
      "fw\\": "vendor/own",
      "app\\": "app"
    }
  },
  "require": {}
}

Урок 3. Конфигурация приложения.
================================
1. Настроить переадресацию на public в .htaccess
2. Создаём конфигурационный файл init
3. Подключаем автозагрузчик composer

Урок 4. Класс реестр
====================
Задача реестра:
	- автоматически создать необходимые объекты при запуске приложения;
	- предоставить доступ из любого места приложения к этим объектам;
	- обеспечить общее место для хранения параметров запуска приложения;
Объект класса реестр создаётся в единственном экземпляре, который хранится в контейнере класса App.
Доступ к контейнеру класса App можно получить из любого места приложения как к статическому свойству.
В объекте класса Registry есть массив параметров приложения.
Любой созданный объект класса App автоматически заполняет массив параметров при инициализации и позволяет записать/получить из любого места.



Урок 5. Класс обработки ошибок.
===============================
Можно назначить пользовательский обработчик ошибок, которые будер работать с учетом режима работы.
set_error_handler([$this, 'errorHandler']);

Но пользовательский обработчик может обработать ошибки не всех уровней.

Для фатальных ошибок надо делать перехват по событию завершения работы скрипта:
	- буферизуем вывод;
	- получаем последнюю ошибку;
	- обрабатываем как нама надо;
ob_start(); //prevent browser output
register_shutdown_function([$this, 'fatalErrorHandler']); //at the end of the script

Для обработки исключений - свой обработчик:
set_exception_handler([$this, 'exeptionHandler']);

Урок 6. Часть 1. Маршрутизатор.
==============================
На основе массива регулярных выражений, называемых правилами, обрабатывает url запрос.
При найденном совпадении, разбирает url, и вызывает соответствующий контроллер и действие.
Структура url: контроллер/действие/параметр?get-параметры.
Структура может быть специализирована для определённых контроллеров, действий или параметров специальными правилами, заданными в routes.php
Например, если встретился такой-то контроллер, с таким-то действием, значит задаём [controller=>'', action=>''] специальные.
Специальные правила должны быть выше, т.е. ближе к началу массива с правилами.

Урок 7. Часть 2. Маршрутизатор.
==============================
Совпавшее регулярное выражение - является ключем в массиве, которому сопоставлен массив, в котором указаны или нет контроллер, метод и префикс.
	Префикс нужен для того, чтобы отделить пользовательскую часть от админской.
В свою очередь, регулярное выражение может вычленять из url название контроллера и метода, которые добавляются в сопоставленный массив
и сохраняются в свойстве класса.
Если что-то не вычленено или не указано, записываются контроллер и метод по умолчанию.
Имена контроллера и метода приводятся в соответствие с PSR-4 и вызываются, если они существуют. Если нет - исключение.

Урок 8. Базовый контроллер
===========================
Предназначен для общего кода для всех контроллеров. От базового контроллера наследуют все остальные.
Наследует через промежуточный AppFeature, в котором мы можем определить какой-то особенный для конкретного приложения код.
В папке с видами для каждого метода контроллера (экшена) создаются папки с соответствующими именами.

Урок 9. Общий класс вида. Часть 1.
==================================
Вызывается в общем классе контроллера Controller.
В общий класс вида передаются все необходимые данные, полученные в результате роутинга для постоения путей к шаблону и виду.
Передаются данные для построения тега meta.
Также есть контейнер для передачи каких-либо других данных, если необходимо.
Ключевая фишка в том, что для вставки вида в шаблон используется буферизация.

Урок 10. Общий класс вида. Часть 2.
==================================
Данные в вид передаются простым записыванием в свойство $data в любом контроллере, унаследовавшем от base Controller.
Передать можно все, запаковать в массив, распаковать и т.д.
Метод render класса View, использующий данные получает их от свойства $data контроллера Controller.

Урок 11. Класс модели.
=======================
Класс модели предназначен для работы с данными в широком смысле.
	1. Подключение к базе данных реализовано классом (паттерн singletone).
	2. Устанавливаем redbinphp.
	
Урок 12. ORM RedBeanPHP
=======================
За подключение к базе используется класс Db, который использует паттерн singletone.
Объект класса Db создается в базовом классе Model.
Класс AppModel наследует от базового Model и является транзитным как AppFeature.
Объект класса AppModel создаётся в транзитном AppFeature.
Через транзитный AppFeature в любом контроллере есть доступ к подключению к базе данных и классу R библиотеки redbeanPHP.

База->Db->Model->AppModel extends Model->AppFeature->MainController extends AppFeature (или любой другой контроллер).
Из контроллера данные передаются в шаблон или вид. Где и используются.

Урок 13. Класс для кэширования.
===============================
Запись и чтение из файла. Самостоятельный класс.
**************************************************************************************************************************************

Урок 1. Перенос шаблона в структуру CMS
========================================
В шаблоне вычленяем постоянную часть и переменную.
Постоянную помещаем в layout-> шаблон.php, а переменную - в вид, для соответствующего контроллера.

Урок 2. Структура базы данных.
==============================

Урок 3. Вывод брендов
======================
В базе получаем данные в массив (в контроллере). Передаём в вид. В виде в цикле выводим.

Урок 4. Вывод популярных товаров.
=================================
Все тоже самое, главное понятная структура. Из планов по улучшению - проверка наличия указанной картинки и ленивая загрузка.
								   - стабильность верстки при отложенной загрузке изображений.
Урок 5. Виджет выбора валют. Часть 1.
=====================================
Из базы данных получаем ассоциативный массив доступных валют, который записываем в объект класса Registry.
	Обращение к классу ядра App обрабатывается автозагрузчиком Composer (App::$appContainer).
	В статическом свойстве $appContainer класса App хранится ссылка на объект в единственном экземпляре Registry 
										(self::$appContainer = Registry::instance();).
	В объекте Registry, в свою очередь, есть свойство, содержащее параметры и методы для получения и записи этих параметров.
Текущюю валюту записываем туда же предварительно получив код текущей валюты (если есть - из куки, если нет - по умолчанию).

Урок 6. Виджет выбора валют. Часть 2.
=====================================
Виджет - часть кода, генерируемого отдельным классом, который вставляется в вид при определённых условиях.

Отдельный класс Currency статичными методами получает массив доступных валют из базы данных и
			значение текущей валюты (из cookie или по-умолчанию).
В промежуточном общем классе AppFeature, используя статичные методы класса Carrency записываем в контейнер приложения 
	массив доступных валют и значение текущей валюты.
	(Почему сразу в классе Carrency это не сделать, создав экземпляр класса в AppFeature???)
В шаблоне создаётся объект класса Carrency, который использует ранее полученные значения валют рендерить виджет в нужном месте.

Текущую валюту, при изменении выбора, надо записать в куки. За это отвечает CurrencyController.

Урок 7. Пересчет цены товара в выбранной валюте.
================================================
В шаблоне мы имеем доступ к массиву текущей валюты. Выводимая цена пересчитывается путем умножения на множитель.
Символ валюты тоже в этом массиве (правый или левый). В шаблоне выводим.

Урок 8. Виджет категорий. Часть 1
==========================================









